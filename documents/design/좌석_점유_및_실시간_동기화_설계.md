# 좌석 일괄 점유 및 실시간 동기화(SSE) 통합 설계

이 문서는 결제 진입 시점의 좌석 일괄 점유 방식과 SSE(Server-Sent Events)를 이용한 실시간 상태 전파 시스템에 대한 최종 설계안을 다룹니다.

---

## 1. 핵심 설계 원칙
1. **결제 진입 시점 일괄 점유 (Atomic Lock on Checkout):** 
    - 사용자가 UI에서 개별 좌석을 선택할 때는 서버와 통신하지 않습니다.
    - [결제하기] 버튼 클릭 시 선택한 모든 좌석을 한꺼번에 서버에 전달하여 점유를 시도합니다.
2. **PostgreSQL Unique 제약 조건 활용:**
    - Redis 도입 전까지는 RDB의 `(schedule_id, row_num, col_num)` Unique Index를 활용하여 동시성을 제어합니다.
3. **SSE 기반 실시간 전파 (Event-Driven UI):**
    - 좌석 상태가 변경(점유/확정/해제)될 때마다 해당 공연 회차의 모든 접속자에게 변경된 좌표 정보만 푸시합니다.

---

## 2. 사용자 시나리오 및 시스템 흐름

### Step 1: 좌석 조회 및 구독
- 사용자가 좌석 선택 페이지 진입 시:
    1. `GET /api/schedules/{id}/seat-status`: 현재 점유/확정된 전체 좌석 목록 로드.
    2. `GET /api/schedules/{id}/seats/stream`: 실시간 업데이트 수신을 위한 SSE 채널 구독.

### Step 2: 좌석 선택 (Client-Side)
- 유저는 화면에서 최대 4석까지 자유롭게 선택/해제. (서버 요청 없음)

### Step 3: 예매 시작 및 일괄 점유
- 유저가 [결제하기] 클릭 시:
    - `POST /api/bookings/start` (Body: `List<SeatPosition>`) 호출.
    - **서버 로직:**
        1. DB 트랜잭션 내에서 요청된 좌석들의 가용성 체크.
        2. `INSERT INTO schedule_seat_status` 수행. 중복 발생 시 `409 Conflict` 반환.
        3. 성공 시 `Booking` 생성 (5분 만료 타이머 시작).
        4. **SSE 이벤트 발행:** `OCCUPIED` 타입으로 선택된 좌석들 전파.

### Step 4: 예매 확정 또는 만료
- **확정:** 결제 성공 시 `CONFIRMED` 이벤트 전파.
- **취소/만료:** 타이머 종료 또는 사용자 취소 시 DB 데이터 삭제 후 `RELEASED` 이벤트 전파.

---

## 3. SSE 메시지 명세

### 이벤트 타입 및 데이터 구조
- **미디어 타입:** `text/event-stream`
- **JSON 페이로드:**
```json
{
  "action": "OCCUPIED | RELEASED | CONFIRMED",
  "seats": [
    { "row": 1, "col": 5 },
    { "row": 1, "col": 6 }
  ]
}
```

---

## 4. 백엔드 기술 상세

### SseService (Emitter 관리)
- `ConcurrentHashMap<Long, List<SseEmitter>>`를 사용하여 회차별 연결 관리.
- **Heartbeat:** 45초마다 빈 데이터를 전송하여 연결 유지 및 503 에러 방지.
- **Cleanup:** `onCompletion`, `onTimeout` 발생 시 즉시 리스트에서 Emitter 제거.

### 동시성 제어 (Concurrency)
- RDB 트랜잭션 격리 수준과 Unique Index를 결합하여 "절대 중복 점유 불가" 보장.
- 성능 임계치 도달 시 점유 로직만 Redis로 이관 가능한 인터페이스 설계.

---

## 5. 프론트엔드 연동 가이드
- 페이지 진입 시 초기 데이터 로드와 SSE 구독을 병렬로 수행.
- SSE 이벤트를 수신하면 전역 상태(Store)를 업데이트하여 좌석 색상 및 선택 가능 여부 즉각 반영.
