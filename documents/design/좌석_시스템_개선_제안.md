# 좌석 시스템 로직 개선 제안서

## 개정이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0 | 2025-12-26 | BE | 초안 작성 (Write-Time Calculation 제안) |
| 1.1 | 2025-12-26 | Claude | 구현 완료 - TicketOption.totalQuantity, ScheduleSeatStatus.seatGrade 추가 |

---

## 1. 현황 및 문제점 분석

### 1.1 현재 로직 (Read-Time Calculation)
현재 `getAvailableSchedulesByDate` 메서드는 조회 요청이 들어올 때마다 다음 과정을 수행합니다.
1. `Venue` 엔티티 조회 (Lazy Loading 가능성)
2. `Venue`의 `seatingChart` JSON 데이터 파싱
3. 파싱된 데이터를 기반으로 등급별 총 좌석 수(`totalSeats`) 계산
4. 예약된 좌석(`BookingSeat`) 조회 후 등급별 집계
5. `totalSeats - occupied` 로직으로 잔여석 계산

### 1.2 주요 문제점
*   **성능 이슈**: 매 조회 요청마다 무거운 JSON 파싱 작업이 반복됩니다. 특히 공연 예매 오픈 직후와 같이 트래픽이 몰리는 시점에 CPU 부하가 급증하여 서비스 장애로 이어질 수 있습니다.
*   **데이터 정합성 취약**: 공연장(Venue) 정보와 회차(Schedule) 정보가 느슨하게 연결되어 있어, 공연장 좌석 배치도가 변경되거나 데이터가 누락될 경우 런타임 에러(잔여석 0 등)가 발생하기 쉽습니다. 디버깅 또한 어렵습니다.
*   **복잡한 조회 쿼리**: 매번 좌석 배치도와 예매 내역을 조인하거나 별도 조회하여 메모리에서 연산해야 하므로 로직이 복잡합니다.

## 2. 개선 제안 (Write-Time Calculation)

### 2.1 핵심 아이디어
**"변하지 않는 정보는 미리 계산하여 저장한다."**
회차별 등급의 총 좌석 수(`totalQuantity`)는 스케줄 생성 시점에 결정되는 불변값(공연장이 바뀌지 않는 한)입니다. 이를 실시간으로 계산할 이유가 없습니다.

### 2.2 변경 구조

#### A. 엔티티 변경 (`TicketOption`)
`TicketOption` 엔티티에 해당 등급의 총 좌석 수 필드를 추가합니다.

```kotlin
@Entity
class TicketOption(
    // ... 기존 필드
    val seatGrade: SeatGrade,
    val price: BigDecimal,
    
    @Column(nullable = false)
    val totalQuantity: Int // [추가] 해당 등급의 총 좌석 수
)
```

#### B. 로직 변경

1.  **스케줄 생성 시 (`createSchedule`)**
    *   `Venue`의 `seatingChart`를 파싱 하여 각 등급별 좌석 수를 계산합니다.
    *   계산된 수량을 `TicketOption`의 `totalQuantity` 필드에 저장합니다.
    *   이 시점에 데이터 유효성 검증(예: Venue 정보 누락 등)을 수행하여, 잘못된 데이터가 생성되는 것을 원천 차단합니다.

2.  **잔여석 조회 시 (`getAvailableSchedulesByDate`)**
    *   JSON 파싱 로직을 완전히 **제거**합니다.
    *   DB에서 `TicketOption.totalQuantity`를 조회하고, 현재 예매 수량만 빼서 반환합니다.
    *   `TicketOption`에 `totalQuantity`가 있으므로 쿼리가 훨씬 단순해집니다.

## 3. 기대 효과

| 항목 | 기존 (AS-IS) | 개선 (TO-BE) |
| :--- | :--- | :--- |
| **성능** | 매 요청마다 JSON 파싱 (느림) | **DB 조회만 수행 (빠름)** |
| **안전성** | 런타임에 데이터 오류 발견 | **생성 시점에 오류 검증 가능** |
| **유지보수** | Venue JSON 의존성 높음 | **의존성 제거 (단순 수치 연산)** |
| **확장성** | 트래픽 증가 시 병목 구간 | **캐싱 적용 용이 (Redis 등)** |

## 4. 실행 계획 (Action Plan)

1.  [x] **엔티티 수정**: `TicketOption` 테이블에 `total_quantity` 컬럼 추가
2.  [x] **생성 로직 수정**: `PerformanceScheduleService.createSchedule`에서 JSON 파싱 및 수량 저장 로직 구현
3.  [x] **조회 로직 단순화**: `getAvailableSchedulesByDate`에서 파싱 로직 제거
4.  [x] **데이터 마이그레이션**: SQL 스크립트 작성 완료

## 5. 추가 구현 사항

1.  [x] **ScheduleSeatStatus에 seatGrade 필드 추가**: 점유 좌석의 등급을 저장하여 DB에서 직접 등급별 집계 가능
2.  [x] **등급별 집계 쿼리 추가**: `countByScheduleIdGroupBySeatGrade` 메서드로 DB에서 직접 집계
3.  [x] **Venue 좌석배치도 변경 시 동기화**: 미래 스케줄의 `TicketOption.totalQuantity` 자동 업데이트

## 6. 마이그레이션 실행 방법

**SQL 스크립트**: `documents/sql/V1__seat_system_migration.sql`

### 실행 방법
```bash
psql -h <host> -U <username> -d <database> -f documents/sql/V1__seat_system_migration.sql
```

### 마이그레이션 내용
1. **TicketOption.total_quantity**: seatingChart JSON에서 등급별 좌석 수 계산하여 저장
2. **ScheduleSeatStatus.seat_grade**: 좌석 위치에 해당하는 등급을 seatingChart에서 조회하여 저장

### 주의사항
- 운영 환경에서는 백업 후 실행을 권장합니다
- DDL(컬럼 추가)은 JPA `ddl-auto: update` 설정으로 자동 처리됩니다
