# [Kotlin] Audit 로그 민감 정보 마스킹 성능 최적화 사례

## 1. 배경
서비스 운영을 위해 사용자 요청 정보(Request Body)를 감사 로그(Audit Log)에 저장해야 합니다. 하지만 사용자가 입력한 **비밀번호(password)**나 **카드 번호(cardNumber)** 같은 민감 정보는 DB에 그대로 저장되면 안 됩니다. 따라서 JSON 문자열 상태에서 해당 필드의 값을 `***`로 마스킹(Masking) 처리하는 로직이 필요했습니다.

이 과정에서 겪었던 3가지 구현 단계와 성능 최적화 과정을 공유합니다.

---

## 2. 구현 단계별 비교

### v1: 단순 메소드 체이닝 (Naive Chaining)
가장 직관적이고 흔하게 작성하는 방식입니다.

```kotlin
private fun maskSensitiveData(requestBody: String?): String? {
    return requestBody
        ?.replace(Regex(""password"\\s*:\s*"[^"]*""), ""password":"***"")
        ?.replace(Regex(""cardNumber"\\s*:\s*"[^"]*""), ""cardNumber":"***"")
        ?.replace(Regex(""cvv"\\s*:\s*"[^"]*""), ""cvv":"***"")
}
```
*   **장점**: 코드가 짧고 읽기 쉽습니다.
*   **단점**:
    *   **성능**: 문자열 전체를 키워드 개수(N)만큼 반복해서 스캔합니다.
    *   **메모리**: `String`은 불변 객체이므로, `replace` 호출마다 새로운 문자열 객체가 생성됩니다.
    *   **디버깅**: 에러 발생 시 어느 라인의 정규식이 문제인지 파악하기 어려울 수 있습니다.

---


### v2: 변수 재할당 (Variable Reassignment)
컴파일러의 타입 추론을 돕고 디버깅을 용이하게 하기 위해 변수를 재할당하는 방식입니다.

```kotlin
private fun maskSensitiveData(requestBody: String?): String? {
    if (requestBody.isNullOrBlank()) return null

    var masked = requestBody
    masked = masked.replace(Regex(""password"\\s*:\s*"[^"]*""), ""password":"***"")
    masked = masked.replace(Regex(""cardNumber"\\s*:\s*"[^"]*""), ""cardNumber":"***"")
    // ...
    return masked
}
```
*   **장점**: 각 단계가 명확히 분리되어 있어 정규식 문법 오류 등을 찾기 쉽습니다.
*   **단점**:
    *   **여전한 성능 문제**: v1과 마찬가지로 불필요한 객체 생성과 반복 스캔이 발생합니다.
    *   **Regex 반복 생성**: 매 호출마다 `Regex` 객체를 새로 컴파일하는 비용이 발생합니다.

---


### v3: 정규식 최적화 (Optimized Regex - Final)
Kotlin의 `Regex` 기능과 `Companion Object`를 활용하여 성능과 유지보수성을 모두 잡은 최종 버전입니다.

#### 개선 포인트
1.  **Pre-compile**: `Regex` 객체를 `static`하게 미리 생성하여 재사용합니다.
2.  **Single Pass**: 여러 키워드를 `|` (OR) 연산자로 합쳐, 문자열을 **단 한 번만 스캔**합니다.
3.  **Lambda Replacement**: 매칭된 그룹(키워드)을 동적으로 활용하여 코드를 간결하게 만듭니다.

```kotlin
companion object {
    // 1. 마스킹할 키워드 목록 정의 (유지보수 포인트)
    private val SENSITIVE_KEYS = listOf(
        "password", "newPassword", "currentPassword",
        "cardNumber", "cvv", "securityCode"
    ).joinToString("|") // 결과: "password|newPassword|..."

    // 2. 정규식 미리 컴파일 (Group 1에 키워드 캡처)
    private val SENSITIVE_DATA_REGEX = Regex(""($SENSITIVE_KEYS)"\\s*:\s*"[^"]*"")
}

private fun maskSensitiveData(requestBody: String?): String? {
    if (requestBody.isNullOrBlank()) return null

    // 3. 단 한 번의 스캔으로 모든 키워드 치환
    return SENSITIVE_DATA_REGEX.replace(requestBody) { matchResult ->
        val key = matchResult.groupValues[1] // 캡처된 키 이름 (예: password)
        ""$key":"***""
    }
}
```

---

## 3. 성능 비교 요약

| 구분 | v1 (체이닝) | v2 (재할당) | v3 (최적화) |
|------|:---:|:---:|:---:|
| **Regex 객체 생성** | 호출마다 N개 | 호출마다 N개 | **최초 1회 (0개)** |
| **문자열 스캔 횟수** | N번 (전체) | N번 (전체) | **1번 (전체)** |
| **중간 객체 생성** | N개 (String) | N개 (String) | **최소화 (StringBuilder)** |
| **코드 유지보수** | 라인 추가 필요 | 라인 추가 필요 | **리스트에 단어만 추가** |

결론적으로, 대용량 트래픽이 발생하는 서비스의 로깅 로직에서는 **v3**와 같은 정규식 최적화가 전체 시스템의 CPU와 메모리 효율을 크게 높여줄 수 있습니다.

```