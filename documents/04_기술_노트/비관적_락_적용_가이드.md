# [기술 가이드] 비관적 락(Pessimistic Lock)을 이용한 데이터 정합성 보장

## 1. 개요
우리 프로젝트는 대규모 트래픽이 발생하는 예매 및 결제 시스템을 다룹니다. 특히 **리프레시 토큰 갱신**이나 **실시간 매출 통계 집계**와 같이 여러 트랜잭션이 동시에 동일한 데이터를 수정하려 할 때, 데이터가 유실되거나 충돌하는 문제가 발생할 수 있습니다.

이를 해결하기 위해 우리는 DB 레벨의 강력한 잠금 매커니즘인 **비관적 락(Pessimistic Lock)**을 채택했습니다.

## 2. 비관적 락이란?
*   **개념**: 데이터를 읽는 시점에 즉시 락을 걸어, 트랜잭션이 완료될 때까지 다른 트랜잭션의 접근(수정/삭제)을 막는 방식입니다.
*   **SQL 레벨**: `SELECT ... FOR UPDATE` 구문과 동일하게 동작합니다.
*   **낙관적 락(Optimistic Lock)과의 차이**:
    *   **낙관적 락**: 충돌이 안 날 것이라 믿고 마지막에 버전(`@Version`)을 체크합니다. 충돌 시 애플리케이션에서 예외 처리가 필요합니다.
    *   **비관적 락**: 충돌이 날 것을 미리 대비하여 줄을 세웁니다. 데이터 무결성이 최우선일 때 사용합니다.

---

## 3. 프로젝트 적용 사례 (Trace Guide)

### 3.1 Spring Data JPA와 비관적 락
우리 프로젝트는 Spring Data JPA의 강력한 기능을 사용하여 비관적 락을 매우 간단하게 적용합니다. 크게 두 가지 방식을 상황에 맞게 선택하여 사용합니다.

#### 방식 A: 메소드 쿼리 (Method Query) 방식
가장 간결한 방식으로, 메소드 이름만으로 쿼리를 생성하고 `@Lock` 어노테이션만 붙입니다.
```kotlin
@Lock(LockModeType.PESSIMISTIC_WRITE)
fun findByEmail(email: String): Optional<User>
```
*   **언제 사용하나?**: 조회 조건이 단순하고, 별도의 JOIN이 필요 없는 경우에 우선적으로 사용합니다.

#### 방식 B: 명시적 쿼리 (@Query) 방식
쿼리를 직접 작성하고 그 위에 `@Lock`을 선언합니다.
```kotlin
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Coupon c WHERE c.code = :code")
fun findByCodeWithLock(code: String): Optional<Coupon>
```
*   **언제 사용하나?**: 
    1.  **명시성**: "이 메소드는 락 획득 전용이다"라는 의도를 동료 개발자에게 명확히 전달하고 싶을 때.
    2.  **복잡성**: `FETCH JOIN`이 필요하거나 복잡한 조건이 들어갈 때.
    3.  **일관성**: 우리 프로젝트는 락 획득을 위한 메소드에 **`WithLock`** 접미사를 붙이는 것을 관례로 하며, 이를 명확히 구분하기 위해 `@Query` 방식을 선호하기도 합니다.

---

## 4. 프로젝트 코드 Trace 예시

### 사례 1: 리프레시 토큰 동시성 이슈 해결 ([CCS-125])
사용자가 여러 기기에서 동시 로그인하거나, 짧은 시간에 토큰 갱신을 중복 요청할 때 `ObjectOptimisticLockingFailureException`이 발생하던 문제를 해결한 사례입니다.

#### STEP 1. Repository 정의
`UserRepository`에서 조회 시점에 `FOR UPDATE` 락을 겁니다.
```kotlin
// UserRepository.kt
@Lock(LockModeType.PESSIMISTIC_WRITE) // 비관적 쓰기 락 적용
@Query("SELECT u FROM User u WHERE u.id = :id")
fun findByIdWithLock(id: Long): Optional<User>
```

#### STEP 2. Service 로직 (Sequence)
1.  사용자 요청이 들어오면 `findByIdWithLock`을 통해 해당 사용자의 행(Row)을 선점합니다.
2.  이때 다른 트랜잭션은 해당 사용자 정보를 수정하기 위해 대기(Wait)하게 됩니다.
3.  안전하게 토큰 리스트를 수정하고 트랜잭션을 마칩니다.

```kotlin
// TokenService.kt
@Transactional
fun refresh(refreshTokenString: String): AuthTokenInfo {
    val tempToken = refreshTokenRepository.findByToken(refreshTokenString).orElseThrow(...)
    
    // [TRACING] 여기서 락을 획득할 때까지 다른 요청은 대기합니다.
    val user = userRepository.findByIdWithLock(tempToken.user.id).orElseThrow(...)

    // 락이 걸린 상태이므로 user.refreshTokens 컬렉션 조작이 안전합니다.
    val refreshToken = user.refreshTokens.find { it.token == refreshTokenString } ?: throw ...
    user.rotateRefreshToken(refreshToken, jwtTokenProvider)
    
    return ...
}
```

---

### 사례 2: 실시간 매출 통계 집계 ([CCS-107])
수천 명이 동시에 결제할 때, 오늘의 총 매출액(`totalSales`)이 겹쳐서 계산되어 누락되는 현상(Lost Update)을 방지합니다.

#### STEP 1. Repository 정의
날짜별 통계 데이터에 락을 겁니다.
```kotlin
// DailySalesStatsRepository.kt
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT s FROM DailySalesStats s WHERE s.date = :date")
fun findByDateWithLock(date: LocalDate): Optional<DailySalesStats>
```

#### STEP 2. Service 로직
여러 결제 성공 이벤트가 동시에 발생해도, 통계 테이블의 특정 날짜 행을 한 번에 하나의 트랜잭션만 수정할 수 있도록 보장합니다.

```kotlin
// SalesStatsService.kt
@Transactional(propagation = Propagation.REQUIRES_NEW)
fun updateDailySales(date: LocalDate, amount: Long, ...) {
    // [TRACING] 오늘 날짜의 통계 행에 락을 겁니다.
    val stats = dailySalesStatsRepository.findByDateWithLock(date)
        .orElseGet { dailySalesStatsRepository.save(DailySalesStats(date = date)) }
    
    // 락을 획득한 상태에서 안심하고 금액을 더합니다. (정확한 합산 보장)
    stats.incrementSales(amount, ...)
}
```

---

## 4. 주의사항 (Senior's Advice)

비관적 락은 강력한 만큼 주의해서 사용해야 합니다.

1.  **데드락(Deadlock) 위험**: 여러 엔티티에 락을 걸 때 순서가 꼬이면 데드락이 발생할 수 있습니다. 항상 일정한 순서로 락을 획득하도록 설계해야 합니다.
2.  **트랜잭션 길이**: 락을 잡고 있는 시간이 길어지면 시스템 전체의 처리량(Throughput)이 떨어집니다. 락이 필요한 로직은 최대한 짧고 굵게 처리하세요.
3.  **대기 시간**: `connection-timeout` 설정과 밀접한 관련이 있습니다. 락 대기가 너무 길어지면 앞서 경험했던 "Connection is not available" 에러의 원인이 될 수 있습니다.

## 5. 결론
우리 프로젝트에서 **`WithLock`** 접미사가 붙은 Repository 메서드는 "데이터 무결성이 매우 중요한 임계 영역"임을 의미합니다. 코드를 작성하거나 수정할 때 이 접미사를 발견한다면, 해당 트랜잭션이 락을 유발함을 인지하고 신중하게 접근해 주시기 바랍니다.
