# 좌석 시스템(JSON) 아키텍처 및 구현 상세

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0  | 2025-12-10 | BE | 신규 좌석 시스템 구현 계획 분석 초안 |
| 1.1  | 2025-12-18 | Gemini | JSON 기반 좌석 시스템의 현재 구현 상세 내용으로 문서 업데이트. |

이 문서는 JSON 기반 좌석 시스템 도입에 대한 초기 분석과 현재 백엔드 시스템에 구현된 상세 내용을 설명합니다.

## 1. 개요: JSON 기반 좌석 시스템 도입 및 현재 구현

JSON 기반 좌석 시스템 도입은 프로젝트의 좌석 관련 핵심 도메인과 비즈니스 로직 전반에 영향을 미치는 아키텍처 변경이었으며, 현재 상당 부분 구현이 완료되었습니다.

## 2. 구현 영역 상세 분석

### 2.1. 데이터 모델 및 DB 구조

*   **`Venue` 엔티티:**
    *   공연장의 좌석 배치 정보 전체(행/열, 등급, 벽, 복도 등)를 담는 **`seatingChart` (TEXT 타입)** 필드가 추가되었습니다. JSON 형태의 문자열로 저장됩니다.
    *   (참고: `Venue.seatingChartUrl` 필드는 `seatingChart`로 대체되었습니다.)
*   **`ScheduleSeatStatus` 엔티티:**
    *   회차별 개별 좌석의 상태(점유, 예약 완료)를 관리하기 위한 `ScheduleSeatStatus` 엔티티가 구현되었습니다.
    *   주요 필드: `schedule_id` (FK), `row_num`, `col_num` (좌석 식별), `status` (ENUM: `PENDING`, `RESERVED`), `held_by` (점유 유저 ID), `held_until` (점유 만료 시간).
    *   (`schedule_id`, `row_num`, `col_num`)에 대한 고유 제약 조건이 설정되어 있습니다.

### 2.2. 핵심 비즈니스 로직

*   **좌석 배치도 서비스 (`VenueService`):**
    *   공연장(Venue)의 좌석 배치 JSON 문자열을 `Venue` 엔티티에 저장/수정하는 로직이 `VenueService.updateSeatingChart` 메서드를 통해 구현되었습니다. (관리자 권한 필요)
*   **좌석 상태 관리 서비스 (`SeatService`):**
    *   **좌석 점유 (`holdSeats`):** 사용자가 특정 좌석을 점유(10분 제한, 최대 4석)하면 `ScheduleSeatStatus`를 `PENDING` 상태로 생성하거나 업데이트합니다.
    *   **좌석 점유 해제 (`releaseSeats`):** 점유 중인 좌석의 `ScheduleSeatStatus`를 삭제합니다.
    *   **좌석 예약 확정 (`reserveSeats`):** `PENDING` 상태의 좌석을 `RESERVED` 상태로 변경합니다.
    *   **점유 만료 처리 (`cleanupExpiredHolds`):** 만료된 `PENDING` 상태 좌석을 정리하는 로직이 구현되어 있습니다. (스케줄러 연동 필요)
    *   **좌석 초기화:** `Venue`의 JSON을 파싱하여 모든 좌석에 대한 `ScheduleSeatStatus` 레코드를 미리 생성하는 명시적인 초기화 로직은 현재 구현되어 있지 않습니다. 좌석 점유 시점에 `ScheduleSeatStatus`가 생성됩니다.
*   **좌석 조회 로직:**
    *   좌석 배치도 정보(JSON)는 `VenueController`의 `GET /api/venues/{venueId}/seating-chart`를 통해 제공됩니다.
    *   개별 좌석 상태 정보(예매 가능/점유/완료)는 `SeatController`의 `GET /api/schedules/{scheduleId}/seat-status`를 통해 제공됩니다. 두 API는 분리되어 프론트엔드에서 조합하여 사용합니다.

### 2.3. API 명세 및 DTO

*   **좌석 배치 관리 API:**
    *   `GET /api/venues/{venueId}/seating-chart`: 공연장의 좌석 배치 JSON 문자열을 조회합니다.
    *   `PUT /api/venues/{venueId}/seating-chart`: 공연장의 좌석 배치 JSON 문자열을 저장/수정합니다. (ADMIN 권한)
*   **좌석 상태 API:**
    *   `GET /api/schedules/{scheduleId}/seat-status`: 특정 회차의 좌석 상태 목록을 조회합니다.
    *   `POST /api/schedules/{scheduleId}/seats/hold`: 좌석 점유를 처리합니다.
    *   `DELETE /api/schedules/{scheduleId}/seats/hold`: 좌석 점유를 해제합니다.
    *   `POST /api/schedules/{scheduleId}/seats/reserve`: 좌석 예약을 확정합니다.
*   **관련 DTO:**
    *   `SeatingChartRequest`, `SeatingChartResponse`
    *   `SeatPositionRequest`, `SeatHoldRequest`, `SeatHoldResponse`, `SeatStatusResponse`, `ScheduleSeatStatusResponse` 등 JSON 구조와 좌석 상태 관리에 필요한 DTO들이 설계 및 구현되었습니다.

---

## 3. 평가: 현재 구현의 장점과 고려 사항

*   **장점:**
    *   프론트엔드에서 좌석 배치도를 렌더링하는 로직이 단순화될 수 있으며, 백엔드는 좌석 배치 정보와 좌석 상태 정보를 분리하여 제공합니다.
    *   `Venue`에 JSON 문자열을 직접 저장하여 유연성을 확보했습니다.
    *   `ScheduleSeatStatus` 엔티티를 통해 회차별 실시간 좌석 상태를 효율적으로 관리합니다.
*   **고려 사항:**
    *   **좌석 초기화**: `Venue`의 JSON을 파싱하여 모든 좌석에 대한 `ScheduleSeatStatus` 레코드를 미리 생성하는 명시적인 초기화 로직은 구현되어 있지 않아, 성능 최적화 관점에서 추가 검토가 필요할 수 있습니다.
    *   **동시성 제어**: `SeatService` 내 좌석 점유/예약 로직에 대한 동시성 제어(예: 비관적 락, Redis 분산 락)는 현재 "추후 구현"으로 계획되어 있습니다.
    *   **좌석 점유 만료 스케줄러**: `cleanupExpiredHolds` 메서드를 주기적으로 호출하는 스케줄러 구현이 필요합니다.
