# 통계 집계 오류 해결 및 성능 최적화 보고서

## 1. 문제 상황 (Incident)
매일 자정에 실행되는 일별 통계 집계 스케줄러(`DailyStatsAggregationScheduler`) 수행 중 다음과 같은 오류가 발생하며 작업이 실패했습니다.

```text
failed to lazily initialize a collection of role: com.github.copyinaction.payment.domain.Payment.paymentItems: could not initialize proxy - no Session
```

이는 JPA의 대표적인 오류인 `LazyInitializationException`으로, 영속성 컨텍스트(Session)가 종료된 이후에 프록시 객체나 지연 로딩(Lazy Loading)된 컬렉션을 초기화하려 할 때 발생합니다.

## 2. 원인 분석 (Root Cause Analysis)

### 2.1 OSIV (Open Session In View) 설정
본 프로젝트는 `application.yml`에서 `jpa.open-in-view: false`로 설정되어 있습니다. 이는 HTTP 요청 처리나 트랜잭션 범위 밖에서는 영속성 컨텍스트를 유지하지 않는다는 의미입니다.

### 2.2 트랜잭션 경계 부재
`DailyStatsAggregationScheduler.aggregateYesterdayStats()` 메서드는 `@Scheduled`에 의해 실행되지만, `@Transactional` 어노테이션이 붙어있지 않았습니다.

1. `paymentRepository.findAllByStatusAndCompletedAtBetween(...)` 호출 시점에는 Repository 내부의 트랜잭션이 동작합니다.
2. 메서드 반환 직후 트랜잭션이 종료되고 영속성 컨텍스트가 닫힙니다.
3. 반환된 `Payment` 엔티티들은 **준영속(Detached)** 상태가 됩니다.
4. 이후 서비스 로직(`salesStatsService.recalculateDailyStats`)에서 `payment.paymentItems`에 접근하려 할 때, 세션이 없으므로(No Session) 초기화에 실패하고 예외가 발생했습니다.

## 3. 해결 방안 (Solution)

이 문제를 해결하고 성능을 최적화하기 위해 다음 3가지 조치를 복합적으로 적용했습니다.

### 3.1 Fetch Join 적용 (Repository 계층)
가장 확실한 방법은 조회 시점에 필요한 데이터를 함께 가져오는 것입니다. `Payment`와 `PaymentItem`은 통계 집계에 필수적인 관계이므로 **Fetch Join**을 적용했습니다.

**수정 전:**
```kotlin
@Query("SELECT p FROM Payment p ...") // Payment만 조회, Item은 프록시로 반환
```

**수정 후:**
```kotlin
@Query("SELECT p FROM Payment p LEFT JOIN FETCH p.paymentItems ...") // Item까지 한 번에 조회 (JOIN)
```

이 조치로 `paymentItems` 접근 시 추가 쿼리가 발생하지 않으며, 초기화 오류도 해결됩니다.

### 3.2 트랜잭션 범위 확장 (Service/Scheduler 계층)
`Payment` 엔티티는 `paymentItems` 외에도 `discounts`(할인 목록)와 같은 다른 지연 로딩 컬렉션을 가지고 있습니다. 모든 컬렉션을 Fetch Join 하면 데이터 중복(Cartesian Product) 문제나 `MultipleBagFetchException`이 발생할 수 있습니다.

따라서 스케줄러 메서드 자체에 `@Transactional`을 적용하여 작업이 끝날 때까지 영속성 컨텍스트를 유지하도록 했습니다.

```kotlin
@Scheduled(...)
@Transactional // 트랜잭션 시작 -> 세션 유지
fun aggregateYesterdayStats() {
    // ... 모든 로직 수행 ...
} // 트랜잭션 종료 -> 세션 닫힘
```

이로써 `recalculateDailyStats` 내부에서 어떤 지연 로딩 필드에 접근하더라도 안전하게 DB 조회가 가능해집니다.

### 3.3 Batch Size 설정 (Global/Performance)
`Fetch Join`을 사용하지 않은 다른 컬렉션(`discounts` 등)을 지연 로딩할 때 발생하는 **N+1 문제**(Payment 100건 조회 시 Discount 조회 쿼리 100번 추가 실행)를 방지하기 위해 `default_batch_fetch_size`를 설정했습니다.

**application.yml:**
```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

**효과:**
지연 로딩이 필요할 때 하나씩 쿼리(`WHERE payment_id = ?`)하는 대신, `IN` 절을 사용하여 최대 100개씩 한 번에 조회(`WHERE payment_id IN (?, ?, ...)`)합니다. 이는 쿼리 수를 획기적으로 줄여줍니다 (N번 -> N/100번).

## 4. 결론
이번 조치를 통해 스케줄러의 안정성을 확보(`LazyInitializationException` 해결)함과 동시에, 대량의 데이터를 처리해야 하는 통계 집계 로직의 DB 조회 성능을 최적화(N+1 방지)했습니다.
