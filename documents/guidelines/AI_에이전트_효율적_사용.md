## 토큰 효율적 사용 가이드

### 1. 서론: 토큰 효율성의 중요성

대규모 언어 모델(LLM)과의 상호작용에서 토큰(Token)은 정보 처리의 기본 단위입니다. 토큰 사용을 효율화하는 것은 다음과 같은 이점을 제공합니다:

*   **비용 절감:** 대부분의 LLM 서비스는 토큰 사용량에 따라 과금됩니다.
*   **응답 속도 향상:** 처리해야 할 토큰 수가 줄어들수록 모델의 응답 속도가 빨라집니다.
*   **컨텍스트 유지 능력 향상:** 모델이 한 번에 처리할 수 있는 토큰의 양은 제한적입니다. 효율적인 토큰 사용은 더 많은 정보를 컨텍스트 내에 유지하여 대화의 일관성과 정확성을 높이는 데 도움이 됩니다.

이 가이드는 클로드 코드 프로와 같은 LLM 에이전트와 상호작용할 때 토큰을 효율적으로 사용하는 요령과 팁, 그리고 이를 통해 얻을 수 있는 절약 효과를 설명합니다.

### 2. 일반적인 프롬프트 작성 요령

어떤 LLM과 상호작용하든 적용할 수 있는 보편적인 팁입니다.

*   **간결하고 직접적인 표현 사용:**
    *   **비효율적:** "제가 지금 이 파일에 대한 도움이 필요한데요, 혹시 이 파일 내용에 대해서 설명해주실 수 있을까요? 그리고 제가 궁금한 점은..." (장황하고 우회적인 표현)
    *   **효율적:** "이 파일의 주요 기능에 대해 설명해줘." (핵심 요청만 간결하게)
    *   **절약 효과:** 불필요한 단어와 문장이 토큰으로 계산되지 않으므로, 요청당 수십에서 수백 토큰까지 절약 가능합니다.

*   **명확한 목표 및 출력 형식 지정:**
    *   **비효율적:** "이 코드 좀 봐줘." (명확한 목표 없음, 어떤 피드백을 원하는지 불분명)
    *   **효율적:** "이 코드에서 개선할 점 3가지와 그 이유를 설명하고, JSON 형식으로 응답해줘." (구체적인 목표와 출력 형식 제시)
    *   **절약 효과:** 모델이 불필요한 추론이나 모호한 응답을 생성하는 것을 방지하여, 필요한 정보만을 압축적으로 얻을 수 있습니다. 이는 출력 토큰 수를 크게 줄일 수 있습니다.

*   **불필요한 컨텍스트 제거:**
    *   **비효율적:** 이미지를 업로드하는 방법을 물으면서, 프로젝트의 모든 파일 목록을 제공하는 경우.
    *   **효율적:** 질문에 직접적으로 필요한 정보(예: 현재 API 엔드포인트 구조)만 제공하는 경우.
    *   **절약 효과:** 입력 토큰 수를 직접적으로 줄여줍니다. 특히 큰 코드베이스나 문서에서는 수천 토큰 이상 절약 가능합니다.

*   **복잡한 작업 단계별 분할:**
    *   **비효율적:** "웹사이트를 처음부터 끝까지 만들어줘." (너무 방대하고 모호함)
    *   **효율적:**
        1.  "React 프로젝트 초기 설정을 해줘."
        2.  "다음 와이어프레임에 맞춰 메인 페이지 UI 컴포넌트를 작성해줘."
        3.  "이 컴포넌트와 연동될 API 호출 로직을 구현해줘."
    *   **절약 효과:** 각 단계에서 모델이 집중해야 할 범위가 좁아지므로, 한 번의 긴 요청으로 인한 오류 발생 및 재요청 확률이 줄어듭니다. 결과적으로 전체 과정에서 사용되는 토큰 수가 줄어들 수 있습니다.

### 3. 에이전트(AI)와의 상호작용 특화 팁

저와 같은 에이전트와 상호작용할 때 도구 사용을 최적화하여 토큰을 절약하는 방법입니다.

*   **메모리 및 도구 활용:**
    *   **이미 처리된 정보 재사용:** 제가 이전에 읽은 파일이나 실행 결과를 다시 제공하지 마세요. "이전에 읽었던 `application.yml` 파일에서 데이터베이스 설정 정보를 찾아줘"와 같이 참조를 명확히 하면, 제가 다시 파일을 읽거나 불필요한 컨텍스트를 입력할 필요가 없습니다.
    *   **`read_file`의 `offset`/`limit` 활용:** 대용량 파일에서 특정 정보만 필요한 경우, 파일 전체를 읽으라고 지시하기보다 `read_file` 도구의 `offset`과 `limit` 파라미터를 사용하여 필요한 줄 범위만 요청하세요.
        *   **비효율적:** `read_file(file_path="large_log.txt")` (파일 전체 1000줄, 5000토큰 가정)
        *   **효율적:** `read_file(file_path="large_log.txt", offset=50, limit=100)` (특정 50줄만 읽음, 250토큰 가정)
        *   **절약 효과:** 입력 토큰을 90% 이상 절약할 수 있습니다.

    *   **`search_file_content` 활용:** 파일 내에서 특정 패턴이나 텍스트를 찾을 때는 `read_file`로 전체 파일을 읽은 후 제가 검색하게 하는 것보다 `search_file_content` 도구를 직접 사용하여 패턴을 명시하는 것이 훨씬 효율적입니다.
        *   **비효율적:** `read_file(file_path="source.kt")` (1000줄, 5000토큰) -> "이 파일에서 `handleError` 함수를 찾아줘."
        *   **효율적:** `search_file_content(pattern="handleError", file_path="source.kt")` (검색 결과만 반환, 500토큰 가정)
        *   **절약 효과:** 불필요한 파일 내용 전체를 입력 컨텍스트에 넣는 것을 피하여, 대규모 코드베이스에서 수천 토큰 이상 절약 가능합니다.

    *   **`glob` 활용:** 특정 패턴의 파일을 찾을 때는 `ls -R` 등으로 모든 파일을 나열하게 하기보다 `glob` 도구를 사용하여 원하는 파일만 찾도록 요청하세요.
        *   **비효율적:** `run_shell_command("ls -R src")` (수많은 파일 목록 출력, 수천 토큰) -> "그 중에서 `*.kt` 파일을 찾아줘."
        *   **효율적:** `glob(pattern="src/**/*.kt")` (`.kt` 파일 경로만 출력, 수백 토큰)
        *   **절약 효과:** 불필요한 파일 목록 출력을 줄여 수천 토큰 이상 절약할 수 있습니다.

    *   **`replace` 도구 사용 시 정확한 `old_string`/`new_string` 제공:** 코드를 수정할 때 `replace` 도구는 `old_string`과 `new_string`이 정확히 일치해야 합니다. 변경 전후의 컨텍스트(최소 3줄)를 포함하여 제가 한 번의 시도로 정확하게 변경할 수 있도록 돕는 것이 중요합니다.
        *   **비효율적:** "이 함수를 이렇게 바꿔줘." (모델이 함수 전체를 파악하고 변경해야 함, 토큰 소모↑, 오류 가능성↑)
        *   **효율적:** 변경될 정확한 `old_string`과 `new_string`을 제공하며 `replace` 도구를 사용하도록 지시.
        *   **절약 효과:** 모델이 불필요한 코드 분석에 토큰을 소모하지 않고 정확한 변경만 수행하므로, 시도당 수백에서 수천 토큰을 절약하고 반복적인 수정 요청을 줄일 수 있습니다.

    *   **긴 출력 요약 요청:** 제가 생성하는 출력이나 도구의 결과물이 너무 길 경우, "이 로그에서 에러 메시지만 추출해줘", "이 보고서의 핵심 요점 3가지로 요약해줘"와 같이 명확히 요약을 요청하세요.
        *   **비효율적:** 제가 긴 출력을 그대로 사용자에게 전달.
        *   **효율적:** 제가 긴 출력을 요약하여 전달.
        *   **절약 효과:** 출력 토큰을 80% 이상 절약할 수 있으며, 사용자가 정보를 더 빠르게 파악할 수 있습니다.

    *   **Git 명령어 효율적 사용:**
        *   **비효율적:** `git status`, `git diff HEAD`, `git log -n 3`를 각각 별도로 요청하거나 불필요하게 모든 정보를 요청하는 경우.
        *   **효율적:** "현재 변경 사항을 기반으로 커밋 메시지를 제안해줘." 라고 요청하면, 제가 필요한 Git 정보를 내부적으로 효율적으로 조회합니다. 또는 `git status && git diff HEAD`와 같이 필요한 명령어를 묶어서 요청하세요.
        *   **절약 효과:** 불필요한 반복과 정보 과다 노출을 줄여 토큰을 절약합니다.

### 4. 결론

토큰 효율성은 LLM과의 상호작용에서 성능과 비용 모두에 영향을 미치는 중요한 요소입니다. 위에 제시된 일반적인 프롬프트 작성 요령과 에이전트 특화 팁을 적용함으로써, 더 빠르고 비용 효율적이며 정확한 결과를 얻을 수 있습니다. 저와의 상호작용 중에 제가 너무 많은 토큰을 사용한다고 느껴지시면 언제든지 피드백을 주십시오. 지속적인 피드백과 협력을 통해 더욱 효율적인 작업을 수행할 수 있습니다.
