# Flyway와 JPA ddl-auto 전략 가이드

이 문서는 Spring Boot 애플리케이션에서 데이터베이스 스키마를 관리하는 두 가지 접근 방식인 JPA `ddl-auto`와 Flyway에 대해 설명하고, 프로젝트 생명주기에 따른 최적의 전략을 선택하고 전환하는 방법을 안내합니다.

---

## 1. 스키마 관리 도구 이해

### 1.1. Flyway란?

Flyway는 데이터베이스 마이그레이션을 위한 오픈소스 버전 관리 도구입니다. 데이터베이스 스키마의 모든 변경 사항(테이블 생성, 컬럼 추가 등)을 SQL 파일 형태로 명시적으로 관리하고 버전화하여, 데이터베이스 구조를 안정적이고 예측 가능하게 진화시킬 수 있도록 돕습니다.

**주요 장점:**
- **버전 관리**: 모든 변경 이력을 코드처럼 관리합니다.
- **일관성**: 개발, 테스트, 운영 등 모든 환경에서 동일한 스키마를 보장합니다.
- **안정성**: JPA `ddl-auto`의 위험성을 배제하고 안전하게 스키마를 변경합니다.
- **협업 용이성**: 여러 개발자의 DB 변경 사항을 충돌 없이 통합할 수 있습니다.

### 1.2. JPA `ddl-auto`란?

`spring.jpa.hibernate.ddl-auto`는 JPA 구현체(Hibernate)가 엔티티 클래스를 기반으로 스키마를 자동으로 처리하는 기능입니다. 개발 초기 단계에서 빠른 프로토타이핑을 가능하게 하지만, 데이터 손실의 위험이 있어 운영 환경 사용에는 부적합합니다.

- **주요 옵션**: `create`, `create-drop`, `update`, `validate`, `none`

---

## 2. Flyway 작동 방식 및 규칙

### 2.1. 마이그레이션 스크립트 규칙

Flyway는 `src/main/resources/db/migration` 디렉터리에 있는 SQL 스크립트 파일의 이름 규칙에 따라 실행 순서를 결정합니다.

- **명명 규칙**: `V<VERSION>__<DESCRIPTION>.sql`
  - `V`: 버전 관리 마이그레이션 접두사.
  - `<VERSION>`: `1`, `2_1`, `202512111000` 등 오름차순으로 정렬 가능한 고유 버전.
  - `__`: 버전과 설명 사이의 구분자 (밑줄 두 개).
  - `<DESCRIPTION>`: 변경 내용을 설명하는 텍스트 (공백 대신 밑줄 사용).
- **예시**: `V1__Create_users_table.sql`, `V2__Add_email_to_users_table.sql`

### 2.2. `flyway_schema_history` 테이블

Flyway는 DB 내부에 `flyway_schema_history`라는 메타데이터 테이블을 자동으로 생성하여, 실행된 마이그레이션의 이력(버전, 실행 시간, 성공 여부 등)을 기록합니다. 애플리케이션 시작 시 이 테이블을 참조하여 아직 적용되지 않은 스크립트만 실행합니다.

---

## 3. Flyway vs. JPA `ddl-auto` 비교

| 항목 | JPA `ddl-auto` | Flyway |
|---|---|---|
| **제어 수준** | **낮음 (자동)** | **높음 (수동)** |
| **스키마 버전 관리** | **없음** | **있음** |
| **안전성 (생산 환경)** | **매우 낮음** | **매우 높음** |
| **편의성 (초기 개발)** | **매우 높음** | **낮음** |
| **협업** | **어려움** | **용이함** |

---

## 4. 권장 시나리오 및 전환 전략

### 4.1. 시나리오 1: 프로젝트 초기, 빠른 프로토타이핑
- **권장**: `spring.jpa.hibernate.ddl-auto = update` (또는 `create`)
- **이유**: 데이터 보존보다 빠른 개발 속도가 중요할 때. 엔티티 모델링에만 집중하여 개발 속도를 극대화할 수 있습니다.

### 4.2. 시나리오 2: 팀 단위 개발, 안정화 및 생산 환경
- **권장**: **Flyway 사용** + `spring.jpa.hibernate.ddl-auto = validate`
- **이유**: 스키마 변경의 안정성, 이력 관리, 협업 효율성이 중요할 때. Flyway로 스키마를 관리하고, `validate` 옵션으로 엔티티와 스키마의 정합성을 추가로 검증하여 안정성을 높입니다.

### 4.3. `ddl-auto`에서 Flyway로 전환하기 (Baseline 설정)

프로젝트가 안정화되어 `ddl-auto`에서 Flyway로 전환할 때 사용하는 표준 절차입니다.

1.  **현재 스키마 DDL 추출**: DB 클라이언트 도구를 사용하여 현재 DB의 전체 스키마를 DDL로 추출합니다.
2.  **`V1` 스크립트 생성**: 추출한 DDL을 `src/main/resources/db/migration/V1__Initial_Schema.sql` 파일로 저장합니다.
3.  **`application.yml` 설정 변경**:
    ```yaml
    spring:
      flyway:
        enabled: true
        baseline-on-migrate: true # DB가 비어있지 않으면, 현재 상태를 baseline으로 간주
        baseline-version: 1       # V1 스크립트와 버전을 맞춤
      jpa:
        hibernate:
          ddl-auto: validate      # Hibernate는 스키마를 검증만 하도록 설정
    ```
4.  **실행 및 확인**: 앱을 실행하면 Flyway는 `V1`을 실행하는 대신, 현재 DB 상태를 `V1`으로 기록만 하고 넘어갑니다.
5.  **새로운 워크플로우**: 이후 모든 스키마 변경은 `V2__...`, `V3__...` 등 새로운 마이그레이션 파일을 통해 관리합니다.

---

## 5. 심화: `Flyway -> ddl-auto -> Flyway` 복귀 전략

이미 Flyway를 사용하던 중 잠시 `ddl-auto`로 전환했다가 다시 Flyway로 복귀하는 경우, **마이그레이션 히스토리를 리셋하고 새로 시작**하는 것이 가장 안전합니다.

### 해결책: 마이그레이션 히스토리 리셋

1.  **마이그레이션 히스토리 리셋 및 새 Baseline 생성**:
    1.  `db/migration` 폴더의 **모든 기존 마이그레이션 파일을 삭제/백업**합니다.
    2.  `ddl-auto`로 최종 변경된 스키마 전체를 DDL로 추출합니다.
    3.  추출한 DDL을 **새로운 `V1` 파일**(`V1__Initial_Schema_After_Refactoring.sql` 등)로 저장합니다.
2.  **데이터베이스 완전 초기화**:
    - 모든 개발 환경의 데이터베이스를 **완전히 삭제하고 새로 생성**하여 깨끗한 상태로 만듭니다.
3.  **`application.yml` 복귀 설정**:
    - `baseline` 관련 설정 없이, 깨끗한 DB에서 새로 시작하도록 설정합니다.
      ```yaml
      spring:
        flyway:
          enabled: true
        jpa:
          hibernate:
            ddl-auto: validate
      ```
4.  **실행 및 새로운 워크플로우**:
    - 앱을 실행하면 Flyway는 깨끗한 DB에서 새로 만든 `V1` 스크립트만 실행하여 스키마를 구축하고 히스토리를 기록합니다. 이후 모든 변경은 `V2`, `V3`로 관리합니다.

---

## 6. 심화: 데이터는 유지하고 히스토리만 리셋하기

개발 과정에서 마이그레이션 이력이 꼬였거나, 특정 버전으로 히스토리를 재설정하고 싶을 때가 있습니다. 예를 들어, 현재 데이터베이스의 스키마와 데이터는 그대로 유지하면서 마이그레이션 기록만 모두 지우고 현재 상태를 `V1`으로 만들고 싶을 때 유용합니다.

**경고: 이 작업은 마이그레이션 내역을 수동으로 조작하므로, 프로덕션 DB에서는 절대 사용해서는 안 됩니다. 반드시 내용을 완전히 이해하고, 실행 전 DB를 백업하세요.**

### 절차: `flywayBaseline`을 이용한 히스토리 재설정

핵심은 **"Flyway가 현재 DB 스키마를 특정 버전(예: V1)으로 이미 적용했다고 믿게 만드는 것"**입니다.

1.  **기존 Flyway 히스토리 삭제**
    - 데이터베이스 관리 툴을 사용하여 `flyway_schema_history` 테이블을 직접 삭제합니다. 이 작업은 다른 데이터 테이블에 영향을 주지 않습니다.
    ```sql
    DROP TABLE IF EXISTS flyway_schema_history;
    ```

2.  **새로운 기준선(Baseline) 설정**
    - 터미널에서 아래 Gradle 명령어를 실행하여 현재 DB 상태를 `V1`으로 강제 설정합니다.
    - 이 명령어는 `V1__...sql` 파일을 **실행하지 않고**, `flyway_schema_history` 테이블에 `V1`이 성공했다는 기록만 남깁니다.
    ```bash
    ./gradlew flywayBaseline -Pflyway.baselineVersion=1 -Pflyway.baselineDescription="Initial schema baseline from existing state"
    ```
    - `-Pflyway.baselineVersion=1`: 기준선 버전을 1로 설정합니다.
    - `-Pflyway.baselineDescription="..."`: 히스토리 테이블에 남길 설명입니다.

3.  **결과 확인 및 향후 작업**
    - DB의 `flyway_schema_history` 테이블을 확인하면 `version = 1`인 기록 하나만 존재합니다.
    - 이제 데이터와 스키마는 보존된 상태에서 마이그레이션 이력만 깨끗하게 `V1`부터 시작할 수 있습니다.
    - 이후 모든 스키마 변경은 `V2__...`, `V3__...` 등 새로운 마이그레이션 파일을 통해 관리하면 됩니다.

### 6.1. Baseline 설정 방법: 명령어 vs. 환경설정

Baseline을 설정하는 두 가지 주요 방법의 장단점을 이해하고 상황에 맞게 사용하는 것이 중요합니다.

#### 1) 명령어 방식 (`./gradlew flywayBaseline`)

명시적으로 특정 조치를 취할 때 가장 적합합니다.

-   **장점**:
    -   **명시성과 안전성**: 언제, 어떻게 베이스라인이 설정되는지 명확하게 제어할 수 있습니다.
    -   **일회성 작업에 적합**: `application.yml`을 수정하지 않고 필요한 조치만 취할 수 있습니다.
-   **추천 시나리오**:
    -   **개발 중 히스토리 리셋**: 로컬에서 마이그레이션이 꼬였을 때, 명확한 의도를 가지고 히스토리를 재설정할 경우.
    -   **운영/스테이징 환경**: 자동화된 설정 변경을 피하고, 안전하게 수동으로 조치해야 할 경우.

#### 2) 환경설정 방식 (`application.yml`)

프로세스를 자동화하고 최초 설정을 간소화할 때 유용합니다.

-   **`application.yml` 예시**:
    ```yaml
    spring:
      flyway:
        enabled: true
        baseline-on-migrate: true
        baseline-version: 1
    ```
-   **장점**:
    -   **자동화**: 앱 실행만으로 조건부(히스토리 테이블이 없거나 비어있을 때) 베이스라인 설정이 가능합니다.
    -   **최초 설정의 편리함**: 팀원이 새 프로젝트를 설정할 때 과정을 단순화합니다.
-   **추천 시나리오**:
    -   **기존 프로젝트에 Flyway 최초 도입**: 팀의 모든 개발자가 처음 프로젝트를 설정할 때 자동으로 베이스라인을 잡을 수 있어 매우 편리합니다. (최초 설정 후에는 `baseline-on-migrate`를 `false`로 변경하거나 삭제하는 것을 권장합니다.)

#### 최종 권장 사항

| 상황 | 추천 방식 | 이유 |
|---:|---|---|
| **기존 프로젝트에 Flyway 최초 도입** | **환경설정 방식** | 최초 1회 설정 자동화로 팀 전체의 설정 과정을 간소화. |
| **개발 중 히스토리 꼬임 해결** | **명령어 방식** | 명시적인 의도를 가지고 안전하게 리셋 작업을 수행. |
| **운영 환경에서의 관리** | **명령어 방식** | 자동화로 인한 실수를 방지하고, 모든 변경을 수동으로 제어. |
