# 예매 시스템 코드 가이드 (개발자 인수인계용)

## 개정이력

| 버전 | 일자 | 작성자 | 내용 |
|------|------|--------|------|
| 1.0 | 2026-01-02 | Claude | 최초 작성 |

---

## 개요

이 문서는 **예매 시스템의 코드 레벨 플로우**를 설명합니다. 이 프로젝트의 핵심 기능이며, 이 플로우를 완벽히 이해하면 프로젝트 전체 아키텍처를 파악한 것과 같습니다.

### 왜 이게 핵심인가?

1. **동시성 처리** - 같은 좌석을 여러 사용자가 동시에 선택하는 상황
2. **5분 타이머** - 결제하지 않으면 자동 만료
3. **실시간 동기화** - SSE로 다른 사용자에게 즉시 반영
4. **Event-Driven Architecture** - Service 간 느슨한 결합

---

## 핵심 파일 (이것만 이해하면 됨)

| 순서 | 파일 | 역할 |
|------|------|------|
| 1 | `booking/service/BookingService.kt` | 오케스트레이터 (진입점) |
| 2 | `booking/domain/Booking.kt` | 도메인 모델 (비즈니스 규칙) |
| 3 | `booking/domain/BookingEvents.kt` | 도메인 이벤트 정의 |
| 4 | `booking/service/BookingEventHandler.kt` | 이벤트 핸들러 |
| 5 | `seat/service/SeatOccupationService.kt` | 좌석 점유/해제 처리 |
| 6 | `seat/service/SseService.kt` | 실시간 푸시 |

---

## 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              예매 플로우                                  │
└─────────────────────────────────────────────────────────────────────────┘

[Client]
    │
    │ POST /api/bookings/start
    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         BookingService                                   │
│                        (Orchestrator)                                    │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ 1. 기존 PENDING 예매 조회 → 취소                                    │  │
│  │ 2. 좌석 변경 계산 (SeatSelection.calculateChanges)                  │  │
│  │ 3. Booking 생성 + BookingSeat 추가                                  │  │
│  │ 4. 도메인 이벤트 등록 (BookingStartedEvent)                         │  │
│  │ 5. save() → 이벤트 발행 트리거                                      │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└────────────────────────────────┬────────────────────────────────────────┘
                                 │
                                 │ Spring ApplicationEvent
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                       BookingEventHandler                                │
│                      (@EventListener)                                    │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ handleBookingStarted(event)                                        │  │
│  │   → seatOccupationService.processSeatChanges()                     │  │
│  │   → seatOccupationService.publishSeatEvents()                      │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└────────────────────────────────┬────────────────────────────────────────┘
                                 │
                    ┌────────────┴────────────┐
                    ▼                         ▼
┌──────────────────────────────┐  ┌──────────────────────────────┐
│   SeatOccupationService      │  │        SseService            │
│  ┌────────────────────────┐  │  │  ┌────────────────────────┐  │
│  │ processSeatChanges()   │  │  │  │ sendOccupied()         │  │
│  │  - releaseSeats()      │  │  │  │ sendReleased()         │  │
│  │  - extendSeats()       │  │  │  │ sendConfirmed()        │  │
│  │  - occupySeats()       │  │  │  └────────────────────────┘  │
│  └────────────────────────┘  │  └──────────────────────────────┘
│              │               │                 │
│              ▼               │                 ▼
│  ┌────────────────────────┐  │     ┌────────────────────┐
│  │ ScheduleSeatStatus     │  │     │   SSE Emitters     │
│  │ (DB Table)             │  │     │   (실시간 푸시)     │
│  └────────────────────────┘  │     └────────────────────┘
└──────────────────────────────┘
```

---

## 상태 전이 다이어그램

```
                    ┌─────────────┐
                    │   (시작)     │
                    └──────┬──────┘
                           │
                           ▼
                    ┌─────────────┐
    ┌──────────────▶│   PENDING   │◀──────────────┐
    │               │  (5분 점유)  │               │
    │               └──────┬──────┘               │
    │                      │                      │
    │         ┌────────────┼────────────┐         │
    │         │            │            │         │
    │         ▼            ▼            ▼         │
    │  ┌───────────┐ ┌───────────┐ ┌───────────┐  │
    │  │ CONFIRMED │ │ CANCELLED │ │  EXPIRED  │  │
    │  │ (결제완료) │ │ (사용자취소)│ │ (시간만료) │  │
    │  └───────────┘ └───────────┘ └───────────┘  │
    │                                             │
    │            [좌석 재선택 시]                   │
    └─────────────────────────────────────────────┘
```

### 상태별 좌석 처리

| Booking 상태 | ScheduleSeatStatus | 설명 |
|--------------|-------------------|------|
| PENDING | PENDING | 5분간 임시 점유 |
| CONFIRMED | RESERVED | 영구 확정 |
| CANCELLED | (삭제됨) | 좌석 해제 |
| EXPIRED | (삭제됨) | 좌석 해제 |

---

## 핵심 플로우 코드 분석

### 1. 예매 시작 (startBooking)

```
파일: booking/service/BookingService.kt
메서드: startBooking(scheduleId, seats, userId)
```

```kotlin
@Transactional
fun startBooking(scheduleId: Long, seats: List<SeatPositionRequest>, userId: Long): BookingResponse {
    // 1️⃣ 사용자/회차 조회
    val user = userRepository.findByIdOrNull(userId)
    val schedule = performanceScheduleRepository.findByIdOrNull(scheduleId)

    // 2️⃣ 기존 PENDING 예매가 있으면 취소 (같은 회차에서 좌석 변경 시)
    val existingBooking = bookingRepository.findBySiteUser_IdAndSchedule_IdAndBookingStatus(
        userId, scheduleId, BookingStatus.PENDING
    )
    existingBooking?.cancel()

    // 3️⃣ 좌석 변경 계산 (유지/추가/해제)
    val oldSelection = SeatSelection(getOldSeatSet(existingBooking))
    val newSelection = SeatSelection(newSeatSet)
    val seatChanges = oldSelection.calculateChanges(newSelection)
    // → SeatChangeResult(kept, released, added)

    // 4️⃣ Booking 도메인 생성
    val newBooking = Booking.create(user, schedule)
    newBooking.addSeats(seatDetails, seatGrade, seatPrice)

    // 5️⃣ 도메인 이벤트 등록 ⭐ 핵심!
    savedBooking.registerEvent(BookingStartedEvent(
        bookingId = savedBooking.id!!,
        scheduleId = scheduleId,
        userId = userId,
        seatChanges = seatChanges
    ))

    // 6️⃣ 저장 → 이벤트 발행 트리거
    bookingRepository.save(savedBooking)

    return BookingResponse.from(savedBooking)
}
```

### 2. 이벤트 핸들러

```
파일: booking/service/BookingEventHandler.kt
```

```kotlin
@EventListener
@Transactional
fun handleBookingStarted(event: BookingStartedEvent) {
    val schedule = performanceScheduleRepository.findByIdOrNull(event.scheduleId)

    // 1️⃣ DB 반영 (좌석 점유/해제/연장)
    seatOccupationService.processSeatChanges(schedule, event.userId, event.seatChanges)

    // 2️⃣ SSE 실시간 푸시
    seatOccupationService.publishSeatEvents(event.scheduleId, event.seatChanges)
}
```

### 3. 좌석 점유 처리

```
파일: seat/service/SeatOccupationService.kt
```

```kotlin
@Transactional
fun processSeatChanges(schedule: PerformanceSchedule, userId: Long, changes: SeatChangeResult) {
    try {
        // 해제될 좌석 삭제
        releaseSeats(scheduleId, userId, changes.released)

        // 유지될 좌석 만료시간 연장
        extendSeats(scheduleId, changes.kept)

        // 새로 추가될 좌석 점유
        occupySeats(schedule, userId, changes.added)

    } catch (e: DataIntegrityViolationException) {
        // ⭐ 동시성 충돌! (다른 사용자가 먼저 점유)
        throw CustomException(ErrorCode.SEAT_ALREADY_OCCUPIED)
    }
}
```

### 4. Booking 도메인 (비즈니스 규칙)

```
파일: booking/domain/Booking.kt
```

```kotlin
class Booking {
    companion object {
        const val BOOKING_VALIDITY_MINUTES = 5L  // 5분 타이머
        const val MAX_SEAT_COUNT = 4             // 최대 4석
    }

    fun addSeat(seat: BookingSeat) {
        validateBookingIsMutable()  // PENDING 상태인지 확인
        if (bookingSeats.size >= MAX_SEAT_COUNT) {
            throw CustomException(ErrorCode.SEAT_LIMIT_EXCEEDED)
        }
        bookingSeats.add(seat)
        recalculateTotalPrice()
    }

    fun confirm() {
        validateBookingIsMutable()
        this.bookingStatus = BookingStatus.CONFIRMED
    }

    fun isExpired(): Boolean {
        return LocalDateTime.now().isAfter(this.expiresAt)
    }
}
```

---

## 도메인 이벤트 목록

```
파일: booking/domain/BookingEvents.kt
```

| 이벤트 | 발생 시점 | 처리 내용 |
|--------|----------|----------|
| `BookingStartedEvent` | 예매 시작 | 좌석 점유 + SSE 발행 |
| `BookingConfirmedEvent` | 결제 완료 | 좌석 상태 RESERVED로 변경 |
| `BookingCancelledEvent` | 예매 취소 | 좌석 해제 + SSE 발행 |

---

## 동시성 처리 전략

### DB Unique 제약 조건

```sql
-- ScheduleSeatStatus 테이블
CREATE UNIQUE INDEX uk_schedule_seat
ON schedule_seat_status(schedule_id, row_num, col_num);
```

### 충돌 처리 흐름

```
User A: 좌석 (1,1) 점유 시도
User B: 좌석 (1,1) 점유 시도 (동시에)
    │
    ▼
┌─────────────────────────────────────┐
│     DB INSERT (Unique 제약)          │
│  ┌─────────────────────────────────┐ │
│  │ User A: INSERT 성공             │ │
│  │ User B: DataIntegrityViolation  │ │
│  └─────────────────────────────────┘ │
└─────────────────────────────────────┘
    │
    ▼
User B → 409 Conflict (SEAT_ALREADY_OCCUPIED)
```

---

## SSE 실시간 동기화

### 구독 흐름

```
1. 클라이언트 → GET /api/schedules/{id}/seats/stream
2. 서버 → SseEmitter 생성 및 등록
3. 좌석 변경 시 → 해당 회차 구독자들에게 이벤트 전송
```

### 이벤트 타입

| 이벤트 | 의미 | 클라이언트 처리 |
|--------|------|----------------|
| `OCCUPIED` | 누군가 점유 시작 | 회색으로 표시 (선택 불가) |
| `RELEASED` | 점유 해제됨 | 선택 가능으로 변경 |
| `CONFIRMED` | 결제 완료됨 | 판매 완료 표시 |

### SSE 메시지 형식

```json
{
  "action": "OCCUPIED",
  "seats": [
    {"row": 1, "col": 5},
    {"row": 1, "col": 6}
  ]
}
```

---

## 예매 확정/취소 플로우

### 예매 확정 (confirmBooking)

```kotlin
@Transactional
fun confirmBooking(bookingId: UUID, userId: Long): BookingResponse {
    val booking = bookingRepository.findByIdOrNull(bookingId)

    // 만료 체크
    if (booking.isExpired()) {
        booking.expire()
        throw CustomException(ErrorCode.BOOKING_EXPIRED)
    }

    // 이벤트 등록 → 좌석 RESERVED로 변경
    booking.registerEvent(BookingConfirmedEvent(...))
    booking.confirm()
    bookingRepository.save(booking)
}
```

### 예매 취소 (cancelBooking)

```kotlin
@Transactional
fun cancelBooking(bookingId: UUID, userId: Long): BookingResponse {
    val booking = bookingRepository.findByIdOrNull(bookingId)

    // PENDING 상태면 좌석 해제 이벤트 등록
    if (booking.bookingStatus == BookingStatus.PENDING) {
        booking.registerEvent(BookingCancelledEvent(...))
    }

    booking.cancel()
    bookingRepository.save(booking)
}
```

---

## 테스트 시나리오

### 1. 기본 예매 플로우

```bash
# 1. 예매 시작
curl -X POST http://localhost:8080/api/bookings/start \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"scheduleId": 1, "seats": [{"row": 1, "col": 1}]}'

# 2. 남은 시간 확인
curl http://localhost:8080/api/bookings/{bookingId}/time \
  -H "Authorization: Bearer $TOKEN"

# 3. 결제 완료
curl -X POST http://localhost:8080/api/bookings/{bookingId}/confirm \
  -H "Authorization: Bearer $TOKEN"
```

### 2. 동시성 테스트

```bash
# 터미널 1: User A가 좌석 점유
curl -X POST http://localhost:8080/api/bookings/start \
  -H "Authorization: Bearer $USER_A_TOKEN" \
  -d '{"scheduleId": 1, "seats": [{"row": 5, "col": 5}]}'

# 터미널 2: User B가 같은 좌석 점유 시도 (동시에)
curl -X POST http://localhost:8080/api/bookings/start \
  -H "Authorization: Bearer $USER_B_TOKEN" \
  -d '{"scheduleId": 1, "seats": [{"row": 5, "col": 5}]}'

# 기대: User B → 409 Conflict
```

### 3. SSE 실시간 테스트

```bash
# 터미널 1: SSE 구독
curl -N http://localhost:8080/api/schedules/1/seats/stream \
  -H "Accept: text/event-stream"

# 터미널 2: 예매 시작 → 터미널 1에서 OCCUPIED 이벤트 수신 확인
```

---

## 디버깅 가이드

### 로그 확인 포인트

```
BookingService    - "예매 시작 - bookingId: {}, scheduleId: {}, 유지: {}, 추가: {}, 해제: {}"
BookingService    - "예매 확정 - bookingId: {}, scheduleId: {}"
BookingService    - "예매 취소 - bookingId: {}, scheduleId: {}"
BookingEventHandler - "이벤트 핸들러 - 예매 시작 처리: bookingId={}"
SeatOccupationService - "좌석 점유 충돌 - scheduleId: {}, userId: {}"
```

### 자주 발생하는 문제

| 증상 | 원인 | 해결 |
|------|------|------|
| 409 Conflict | 다른 사용자가 먼저 점유 | 정상 동작, 클라이언트에서 재선택 유도 |
| 410 Gone | 5분 타이머 만료 | 클라이언트에서 처음부터 재시작 |
| SSE 연결 끊김 | 서버 타임아웃 | heartbeat 설정 확인 (45초) |

---

## 관련 문서

- [좌석 예매 시스템](./좌석_예매_시스템.md) - API 명세, 데이터 모델
- [좌석 점유 및 동기화 설계](../02_시스템_아키텍처/좌석_점유_및_동기화_설계.md)
- [이벤트 기반 좌석 처리](../02_시스템_아키텍처/이벤트_기반_좌석_처리.md)
