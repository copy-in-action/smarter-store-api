# 좌석 예매 시스템 - 테스트 워크플로우 (Lite)

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0  | 2025-12-22 | BE | 초안 작성 |
| 2.0  | 2025-12-22 | Gemini | 일괄 점유 및 SSE 스트림 테스트 시나리오로 전면 개정 |
| 2.1  | 2025-12-26 | Claude | Write-Time Calculation 적용에 따른 체크리스트 추가 |

---

## 1. 사전 준비
- **SSE 구독**: 브라우저 탭 2개(사용자 A, 사용자 B)를 열고 각각 `GET /api/schedules/{id}/seats/stream` 구독.
- **초기 상태**: `GET /api/schedules/{id}/seat-status`로 현재 비어있는 좌석 확인.

---

## 2. 통합 시나리오 테스트

### Step 1: 일괄 점유 및 예매 시작 (사용자 A)
- **Action**: 사용자 A가 1열 1번, 1열 2번 좌석 선택 후 [결제하기] 클릭.
- **Request**: `POST /api/bookings/start` { "seats": [{"row":1, "col":1}, {"row":1, "col":2}] }
- **Expected**:
    - **A의 응답**: 200 OK, `bookingId` 수신, 5분 타이머 시작.
    - **B의 화면**: SSE를 통해 `OCCUPIED` 이벤트를 수신하고, 1열 1번/2번 좌석이 즉시 점유 상태(회색)로 변경됨.

### Step 2: 동시성 충돌 테스트 (사용자 B)
- **Action**: 사용자 B가 사용자 A가 이미 점유한 1열 1번을 포함하여 [결제하기] 클릭.
- **Request**: `POST /api/bookings/start` { "seats": [{"row":1, "col":1}, {"row":1, "col":5}] }
- **Expected**:
    - **B의 응답**: 409 Conflict (`SEAT_ALREADY_OCCUPIED`).
    - **데이터**: B의 1열 5번 좌석도 점유되지 않아야 함 (Atomic Rollback).

### Step 3: 예매 만료 및 자동 해제
- **Action**: 사용자 A가 결제하지 않고 5분 대기.
- **Expected**:
    - **서버**: 스케줄러가 `Booking`을 `EXPIRED`로 변경하고 `ScheduleSeatStatus` 삭제.
    - **A/B의 화면**: SSE를 통해 `RELEASED` 이벤트를 수신하고, 1열 1번/2번 좌석이 다시 선택 가능 상태로 복구됨.

### Step 4: 예매 확정 (사용자 A)
- **Action**: 사용자 A가 다시 점유 후 [결제 확정] 클릭.
- **Request**: `POST /api/bookings/{bookingId}/confirm`
- **Expected**:
    - **A의 응답**: 200 OK, `status: CONFIRMED`.
    - **B의 화면**: SSE를 통해 `CONFIRMED` 이벤트를 수신하고, 해당 좌석이 영구 판매 완료 상태로 변경됨.

---

## 3. SSE 연결 안정성 테스트
- **Heartbeat 확인**: 약 45초 간격으로 서버에서 빈 데이터(또는 주석)가 오는지 확인.
- **재연결 테스트**: 네트워크 강제 단절 후 복구 시 브라우저가 다시 구독을 시도하는지 확인.

---

## 4. 체크리스트
- [ ] 여러 좌석 선택 시 하나라도 실패하면 전체 롤백되는가?
- [ ] SSE 이벤트 수신 시 UI가 새로고침 없이 즉각 변하는가?
- [ ] `GET /time` API가 새로고침 후에도 정확한 남은 시간을 주는가?