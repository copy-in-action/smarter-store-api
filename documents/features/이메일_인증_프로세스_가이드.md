## 이메일 인증 프로세스 가이드

이 문서는 Smarter Store API에 구현된 이메일 인증 프로세스를 설명합니다. 사용자 계정 보안 강화 및 이메일 유효성 확인이 주 목적입니다.

---

### 목차

1.  [개요](#1-개요)
2.  [프로세스 참여자](#2-프로세스-참여자)
3.  [프로세스 흐름](#3-프로세스-흐름)
    *   [3.1. 인증 요청 단계](#31-인증-요청-단계)
    *   [3.2. 인증 확인 단계](#32-인증-확인-단계)
4.  [API 엔드포인트](#4-api-엔드포인트)
5.  [데이터베이스 스키마](#5-데이터베이스-스키마)
6.  [이메일 전송 설정 (Spring Mail Sender)](#6-이메일-전송-설정-spring-mail-sender)
7.  [주요 고려사항](#7-주요-고려사항)
8.  [오류 처리](#8-오류-처리)

---

### 1. 개요

**Smarter Store API**의 이메일 인증은 사용자 계정의 보안을 강화하고, 사용자가 제공한 **이메일 주소의 유효성** 및 **소유권**을 확인하는 중요한 절차입니다.

### 2. 프로세스 참여자

이 프로세스에는 다음과 같은 주요 시스템과 주체가 관여합니다.

*   **사용자 (User):** 회원가입, 이메일 인증 요청 및 전송된 이메일을 통한 인증 완료 주체.
*   **클라이언트 (Client):** 웹/모바일 애플리케이션 등 API 서버와 상호작용하여 이메일 인증 요청 및 확인을 수행.
*   **API 서버 (API Server):**
    *   인증 토큰 생성, 저장 및 유효성 검사.
    *   **EmailService**를 통한 이메일 발송 지시 및 사용자 계정 인증 상태 업데이트.
*   **이메일 서비스 (Email Service):** API 서버의 지시에 따라 사용자에게 인증 이메일을 실제로 발송하는 시스템 (예: Spring Mail Sender, 외부 SMTP 서비스).
*   **데이터베이스 (Database):** 사용자 정보(`User` 엔티티) 및 이메일 인증 토큰 정보(`EmailVerificationToken` 엔티티)를 저장.

### 3. 프로세스 흐름

이메일 인증 프로세스는 크게 **인증 요청**과 **인증 확인** 두 단계로 나뉩니다.

#### 3.1. 인증 요청 단계

사용자가 인증 이메일 발송을 요청하는 과정입니다.

1.  **사용자 행동:**
    *   회원가입을 완료하거나, 이메일 인증이 필요한 상황에서 **클라이언트를 통해 인증 이메일 발송을 요청**합니다.
2.  **클라이언트 -> API 서버 (요청):**
    *   클라이언트는 사용자 이메일 주소를 포함하여 API 서버의 **인증 요청 엔드포인트**로 `POST` 요청을 보냅니다.
    *   **엔드포인트:** `POST /api/auth/email-verification/request`
    *   **요청 바디 예시:**
        ```json
        {
          "email": "user@example.com"
        }
        ```
3.  **API 서버 처리:**
    *   요청된 이메일로 `User` 정보를 조회합니다.
        *   **사용자가 존재하지 않으면** `EMAIL_NOT_FOUND` 오류 반환.
        *   **이미 인증된 이메일이라면** `EMAIL_ALREADY_VERIFIED` 오류 반환.
    *   **유효한 사용자이며 미인증 상태일 경우:**
        *   고유한 **인증 토큰** (UUID 기반)을 생성합니다.
        *   생성된 토큰과 **만료 시간** (예: 30분 후)을 포함하는 `EmailVerificationToken` 엔티티를 생성하고 데이터베이스에 저장합니다. (기존 토큰이 있다면 삭제 후 새로 생성)
        *   **EmailService**를 통해 **사용자 이메일 주소**와 **인증 토큰**이 포함된 **인증 링크/코드**를 발송하도록 지시합니다.
4.  **이메일 서비스 -> 사용자 (발송):**
    *   이메일 서비스는 인증 링크(예: `http://localhost:8080/api/auth/email-verification/confirm?token={YOUR_TOKEN}`)가 포함된 이메일을 사용자에게 발송합니다.

#### 3.2. 인증 확인 단계

사용자가 이메일을 통해 인증을 완료하는 과정입니다.

1.  **사용자 행동:**
    *   수신된 이메일의 **인증 링크를 클릭**하거나, 이메일에 포함된 **인증 코드를 클라이언트 입력 폼에 입력**합니다.
2.  **클라이언트 -> API 서버 (요청):**
    *   클라이언트는 사용자가 클릭한 링크의 토큰 값 또는 입력한 코드를 포함하여 API 서버의 **인증 확인 엔드포인트**로 `POST` 요청을 보냅니다.
    *   **엔드포인트:** `POST /api/auth/email-verification/confirm`
    *   **요청 바디 예시:**
        ```json
        {
          "token": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
        }
        ```
3.  **API 서버 처리:**
    *   요청된 토큰 값으로 `EmailVerificationToken` 정보를 조회합니다.
        *   **토큰이 존재하지 않으면** `INVALID_EMAIL_VERIFICATION_TOKEN` 오류 반환.
        *   **토큰이 만료되었으면** `EXPIRED_EMAIL_VERIFICATION_TOKEN` 오류 반환 후 해당 토큰 삭제.
    *   **유효한 토큰일 경우:**
        *   토큰에 연결된 `User` 정보를 조회합니다.
        *   해당 `User`의 `isEmailVerified` 필드를 `true`로 업데이트하고 데이터베이스에 저장합니다.
        *   **사용된 `EmailVerificationToken`은 데이터베이스에서 삭제**합니다.
4.  **클라이언트 (인증 성공 알림):**
    *   API 서버로부터 성공 응답을 받은 클라이언트는 사용자에게 **이메일 인증이 성공적으로 완료되었음**을 알립니다.

### 4. API 엔드포인트

이메일 인증 관련 API 엔드포인트 목록입니다. 상세한 요청 및 응답 형식은 API 문서 (Swagger UI)를 참고하십시오.

*   **이메일 인증 요청:**
    *   **메서드:** `POST`
    *   **URL:** `/api/auth/email-verification/request`
    *   **설명:** 지정된 이메일 주소로 인증 이메일을 보냅니다.
    *   **요청 바디 예시:**
        ```json
        {
          "email": "user@example.com"
        }
        ```
*   **이메일 인증 확인:**
    *   **메서드:** `POST`
    *   **URL:** `/api/auth/email-verification/confirm`
    *   **설명:** 받은 토큰으로 이메일 인증을 완료합니다.
    *   **요청 바디 예시:**
        ```json
        {
          "token": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
        }
        ```

### 5. 데이터베이스 스키마

이메일 인증 프로세스와 관련된 주요 엔티티 및 필드입니다.

*   **`User` 엔티티:**
    *   `isEmailVerified`: `Boolean` (기본값: `false`)
        *   **설명:** 사용자의 이메일 인증 상태를 나타냅니다. `true`이면 인증 완료, `false`이면 미인증.

*   **`EmailVerificationToken` 엔티티:**
    *   **주요 필드:**
        *   `id`: `Long` (자동 생성 ID)
        *   `token`: `String` (고유한 인증 토큰)
        *   `user`: `User` (해당 토큰이 연결된 사용자, `OneToOne` 관계)
        *   `expiryDate`: `LocalDateTime` (토큰의 만료 시간)
    *   **상속 필드:** `BaseEntity`로부터 `createdAt`, `updatedAt` 상속.

### 6. 이메일 전송 설정 (Spring Mail Sender)

Spring Mail Sender를 통해 이메일을 전송하려면 `build.gradle.kts`에 의존성을 추가하고, `application-local.yml` (또는 `application.yml`)에 SMTP 서버 정보를 설정해야 합니다.

#### 6.1. `build.gradle.kts` 의존성 추가 (이미 완료됨)

`dependencies` 블록에 다음 의존성이 추가되어 있어야 합니다.

```gradle
implementation("org.springframework.boot:spring-boot-starter-mail")
```

#### 6.2. `application-local.yml` 설정

이메일 전송을 위해 실제 사용하실 SMTP 서버 정보를 `application-local.yml` 파일에 채워 넣어야 합니다. 아래 예시를 참고하여 플레이스홀더(`your-email@example.com`, `your-password`)를 실제 정보로 대체하십시오. Gmail을 사용하는 경우, 일반 비밀번호 대신 앱 비밀번호를 생성하여 사용하는 것을 권장합니다.

```yaml
spring:
  mail:
    host: # Your SMTP host (e.g., smtp.gmail.com, smtp.naver.com)
    port: 587 # Often 587 for STARTTLS, 465 for SSL/TLS
    username: # Your email address (e.g., your-email@example.com)
    password: # Your email password or app-specific password
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000
          # If you encounter issues with trust, you might need to enable SSL trust
          # ssl:
          #   trust: "*"
```

#### 6.3. `MailConfig.kt` (이미 완료됨)

`src/main/kotlin/com/github/copyinaction/config/MailConfig.kt` 파일에 `JavaMailSender` 빈이 다음과 같이 정의되어 있습니다. 이 설정은 위 `application-local.yml`에서 읽어온 속성들을 사용하여 `JavaMailSender`를 구성합니다.

```kotlin
@Configuration
class MailConfig(
    @Value("\${spring.mail.host}") private val host: String,
    // ... (other properties)
) {
    @Bean
    fun javaMailSender(): JavaMailSender {
        // ... (JavaMailSender configuration using injected properties)
    }
}
```

### 7. 주요 고려사항

*   **토큰 유효 기간:** `EmailVerificationToken`의 `expiryDate`는 **적절히 설정**되어야 합니다 (예: 30분). 만료된 토큰은 API 서버에서 거부됩니다.
*   **이메일 재전송:** 사용자가 인증 이메일을 받지 못했거나 만료된 경우를 대비하여 **재전송 기능**을 제공해야 합니다. 재전송 시에는 기존 토큰을 삭제하고 새로운 토큰을 생성하여 발송해야 합니다.
*   **이메일 템플릿:** 사용자에게 발송되는 이메일은 **명확하고 친절한 지침**을 포함해야 합니다. 인증 링크, 토큰 만료 시간 등의 정보를 제공합니다.
*   **보안:**
    *   인증 토큰은 **예측 불가능하고 충분히 길어야** 합니다 (예: `UUID` 사용).
    *   토큰은 데이터베이스에 **안전하게 저장**되어야 하며, 만료 시 또는 사용 즉시 **무효화/삭제**되어야 합니다.
    *   인증 링크는 **HTTPS**를 사용해야 합니다.

### 8. 오류 처리

이메일 인증 프로세스 중 발생할 수 있는 주요 오류와 해당 `ErrorCode`입니다.

*   `EMAIL_NOT_FOUND`: (`HTTP 404`) 요청된 이메일 주소로 등록된 사용자가 없습니다.
*   `EMAIL_ALREADY_VERIFIED`: (`HTTP 409`) 해당 이메일이 이미 인증된 상태입니다.
*   `INVALID_EMAIL_VERIFICATION_TOKEN`: (`HTTP 400`) 제공된 인증 토큰이 유효하지 않거나 존재하지 않습니다.
*   `EXPIRED_EMAIL_VERIFICATION_TOKEN`: (`HTTP 400`) 제공된 인증 토큰이 만료되었습니다.
*   `INTERNAL_SERVER_ERROR`: (`HTTP 500`) 이메일 발송 시스템 오류 등 서버 내부 문제.
