# MinIO를 활용한 공연 이미지 업로드 가이드

## 목차

1. [개요](#1-개요)
2. [사전 준비](#2-사전-준비)
3. [백엔드 구현 가이드](#3-백엔드-구현-가이드)
4. [API 엔드포인트](#4-api-엔드포인트)
5. [Admin UI 흐름](#5-admin-ui-흐름)
6. [요청/응답 형식](#6-요청응답-형식)
7. [이미지 처리 흐름](#7-이미지-처리-흐름)
8. [오류 처리](#8-오류-처리)

---

## 1. 개요

이 문서는 Smarter Store API 서버의 공연 등록 시 MinIO를 활용한 이미지 업로드 방법을 안내합니다.

**핵심 흐름:**
1. 공연 생성 API 호출 → 공연 ID 획득
2. 이미지 업로드 API 호출 → `mainImageUrl` 자동 업데이트

---

## 2. 사전 준비

### 2.1 MinIO 서버 설치 및 실행

**Docker를 이용한 MinIO 실행:**

```bash
docker run -d \
  --name minio \
  -p 9000:9000 \
  -p 9001:9001 \
  -e "MINIO_ROOT_USER=minioadmin" \
  -e "MINIO_ROOT_PASSWORD=minioadmin" \
  -v minio_data:/data \
  minio/minio server /data --console-address ":9001"
```

- **API 엔드포인트:** `http://localhost:9000`
- **콘솔 UI:** `http://localhost:9001`

### 2.2 버킷 생성

MinIO 콘솔(`http://localhost:9001`)에 접속하여 `smarter-store` 버킷을 생성합니다.

### 2.3 환경변수 설정

`.env` 파일에 다음 환경변수를 추가합니다:

```properties
# MinIO Configuration
MINIO_ENDPOINT=http://localhost:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET_NAME=smarter-store
```

---

## 3. 백엔드 구현 가이드

### 3.1 의존성 추가

`build.gradle.kts`에 MinIO SDK 의존성을 추가합니다:

```kotlin
dependencies {
    // MinIO
    implementation("io.minio:minio:8.5.7")
}
```

### 3.2 application.yml 설정

```yaml
minio:
  endpoint: ${MINIO_ENDPOINT:http://localhost:9000}
  access-key: ${MINIO_ACCESS_KEY:minioadmin}
  secret-key: ${MINIO_SECRET_KEY:minioadmin}
  bucket-name: ${MINIO_BUCKET_NAME:smarter-store}

spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
```

### 3.3 MinioConfig

`src/main/kotlin/com/github/copyinaction/storage/config/MinioConfig.kt`:

```kotlin
package com.github.copyinaction.storage.config

import io.minio.MinioClient
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class MinioConfig(
    @Value("\${minio.endpoint}") private val endpoint: String,
    @Value("\${minio.access-key}") private val accessKey: String,
    @Value("\${minio.secret-key}") private val secretKey: String
) {
    @Bean
    fun minioClient(): MinioClient {
        return MinioClient.builder()
            .endpoint(endpoint)
            .credentials(accessKey, secretKey)
            .build()
    }
}
```

### 3.4 StorageService

`src/main/kotlin/com/github/copyinaction/storage/service/StorageService.kt`:

```kotlin
package com.github.copyinaction.storage.service

import io.minio.*
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import java.util.UUID

@Service
class StorageService(
    private val minioClient: MinioClient,
    @Value("\${minio.bucket-name}") private val bucketName: String,
    @Value("\${minio.endpoint}") private val endpoint: String
) {
    init {
        createBucketIfNotExists()
    }

    private fun createBucketIfNotExists() {
        val exists = minioClient.bucketExists(
            BucketExistsArgs.builder().bucket(bucketName).build()
        )
        if (!exists) {
            minioClient.makeBucket(
                MakeBucketArgs.builder().bucket(bucketName).build()
            )
        }
    }

    fun uploadFile(file: MultipartFile, directory: String): String {
        val extension = file.originalFilename?.substringAfterLast('.', "") ?: ""
        val fileName = "${UUID.randomUUID()}.$extension"
        val objectName = "$directory/$fileName"

        minioClient.putObject(
            PutObjectArgs.builder()
                .bucket(bucketName)
                .`object`(objectName)
                .stream(file.inputStream, file.size, -1)
                .contentType(file.contentType ?: "application/octet-stream")
                .build()
        )

        return "$endpoint/$bucketName/$objectName"
    }

    fun deleteFile(objectName: String) {
        minioClient.removeObject(
            RemoveObjectArgs.builder()
                .bucket(bucketName)
                .`object`(objectName)
                .build()
        )
    }
}
```

### 3.5 PerformanceImageController

`src/main/kotlin/com/github/copyinaction/performance/controller/PerformanceImageController.kt`:

```kotlin
package com.github.copyinaction.performance.controller

import com.github.copyinaction.storage.dto.ImageUploadResponse
import com.github.copyinaction.storage.service.StorageService
import com.github.copyinaction.performance.service.PerformanceService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.bind.annotation.*
import org.springframework.web.multipart.MultipartFile

@Tag(name = "performance-images", description = "공연 이미지 API")
@RestController
@RequestMapping("/api/v1/performances")
class PerformanceImageController(
    private val storageService: StorageService,
    private val performanceService: PerformanceService
) {
    @Operation(
        summary = "공연 이미지 업로드",
        description = "공연에 이미지를 업로드합니다. THUMBNAIL 타입은 메인 이미지로 자동 설정됩니다."
    )
    @SecurityRequirement(name = "bearerAuth")
    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping(
        "/{performanceId}/images",
        consumes = [MediaType.MULTIPART_FORM_DATA_VALUE]
    )
    fun uploadImage(
        @Parameter(description = "공연 ID") @PathVariable performanceId: Long,
        @Parameter(description = "업로드할 이미지 파일") @RequestPart("file") file: MultipartFile,
        @Parameter(description = "이미지 타입 (THUMBNAIL, DETAIL, BANNER)")
        @RequestParam(required = false) imageType: String?
    ): ResponseEntity<ImageUploadResponse> {
        // 공연 존재 여부 확인
        performanceService.getPerformance(performanceId)

        // 파일 유효성 검사
        validateImageFile(file)

        // MinIO에 업로드
        val directory = "performances/$performanceId"
        val imageUrl = storageService.uploadFile(file, directory)

        // THUMBNAIL인 경우 공연의 mainImageUrl 자동 업데이트
        if (imageType == "THUMBNAIL") {
            performanceService.updateMainImageUrl(performanceId, imageUrl)
        }

        return ResponseEntity.ok(ImageUploadResponse(imageUrl, imageType))
    }

    private fun validateImageFile(file: MultipartFile) {
        val allowedTypes = listOf("image/jpeg", "image/png", "image/gif", "image/webp")
        val maxSize = 10 * 1024 * 1024L // 10MB

        require(!file.isEmpty) { "파일이 비어있습니다." }
        require(file.contentType in allowedTypes) {
            "허용되지 않는 파일 형식입니다. (허용: JPEG, PNG, GIF, WebP)"
        }
        require(file.size <= maxSize) {
            "파일 크기가 10MB를 초과합니다."
        }
    }
}
```

### 3.6 PerformanceService 메서드 추가

```kotlin
@Transactional
fun updateMainImageUrl(performanceId: Long, imageUrl: String) {
    val performance = findPerformanceById(performanceId)
    performance.mainImageUrl = imageUrl
}
```

### 3.7 ImageUploadDto

`src/main/kotlin/com/github/copyinaction/storage/dto/ImageUploadDto.kt`:

```kotlin
package com.github.copyinaction.storage.dto

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "이미지 업로드 응답 DTO")
data class ImageUploadResponse(
    @Schema(description = "업로드된 이미지 URL")
    val imageUrl: String,

    @Schema(description = "이미지 타입")
    val imageType: String?
)

enum class ImageType {
    THUMBNAIL,  // 썸네일/메인 이미지
    DETAIL,     // 상세 이미지
    BANNER      // 배너 이미지
}
```

---

## 4. API 엔드포인트

| Method | URL | 설명 |
|--------|-----|------|
| POST | `/api/performances` | 공연 생성 |
| POST | `/api/v1/performances/{performanceId}/images` | 이미지 업로드 |

---

## 5. Admin UI 흐름

### 5.1 공연 등록 + 이미지 업로드

```
┌─────────────────────────────────────────────────────────┐
│  Admin: 공연 등록 화면                                    │
│                                                         │
│  [공연 정보 입력]  +  [이미지 선택]  +  [등록 버튼 클릭]     │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Step 1: POST /api/performances                         │
│  → 공연 생성 (mainImageUrl: null, visible: false)        │
│  → 응답: { id: 123, ... }                               │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Step 2: POST /api/v1/performances/123/images           │
│  → 이미지 MinIO 업로드                                   │
│  → mainImageUrl 자동 업데이트                            │
│  → 응답: { imageUrl: "http://...", imageType: "..." }   │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  완료: 공연 등록 + 이미지 업로드 완료                       │
└─────────────────────────────────────────────────────────┘
```

### 5.2 JavaScript 구현 예시

```javascript
async function createPerformanceWithImage(formData, imageFile) {
  const token = getAuthToken();

  // 1. 공연 생성
  const performanceRes = await fetch('/api/performances', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      title: formData.title,
      category: formData.category,
      description: formData.description,
      startDate: formData.startDate,
      endDate: formData.endDate,
      visible: false  // 기본값: 미노출
      // mainImageUrl은 null로 생성됨
    })
  });

  const performance = await performanceRes.json();

  // 2. 이미지가 있으면 업로드 (mainImageUrl 자동 업데이트)
  if (imageFile) {
    const imgForm = new FormData();
    imgForm.append('file', imageFile);
    imgForm.append('imageType', 'THUMBNAIL');

    await fetch(`/api/v1/performances/${performance.id}/images`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      },
      body: imgForm
    });
  }

  return performance;
}
```

### 5.3 공연 노출 설정

공연의 노출 여부는 `visible` 필드로 관리합니다:
- `visible: false` (기본값) - 미노출 상태로 생성
- `visible: true` - 사용자에게 노출

```javascript
// 공연 노출 상태 변경
async function updatePerformanceVisibility(performanceId, visible) {
  const performance = await getPerformance(performanceId);

  await fetch(`/api/performances/${performanceId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      ...performance,
      visible: visible  // true: 노출, false: 미노출
    })
  });
}
```

---

## 6. 요청/응답 형식

### 6.1 공연 생성 요청

```json
POST /api/performances
{
  "title": "2025 HYOLYN CONCERT",
  "category": "콘서트",
  "description": "효린 콘서트입니다.",
  "runningTime": 120,
  "ageRating": "15세 이상 관람가",
  "visible": false,
  "venueId": 1,
  "startDate": "2025-12-20",
  "endDate": "2025-12-31"
}
```

### 6.2 이미지 업로드 요청

```bash
curl -X POST \
  http://localhost:8080/api/v1/performances/123/images \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN' \
  -F 'file=@/path/to/image.jpg' \
  -F 'imageType=THUMBNAIL'
```

### 6.3 이미지 업로드 응답

```json
{
  "imageUrl": "http://localhost:9000/smarter-store/performances/123/uuid.jpg",
  "imageType": "THUMBNAIL"
}
```

---

## 7. 이미지 처리 흐름

```
┌─────────────┐     ┌─────────────────┐     ┌─────────────┐
│   Client    │────>│   API Server    │────>│    MinIO    │
│             │     │                 │     │             │
│ 이미지 전송  │     │ 1. JWT 인증 확인  │     │ 이미지 저장  │
│             │     │ 2. 공연 존재 확인  │     │             │
│             │     │ 3. 파일 유효성검사 │     │             │
│             │     │ 4. MinIO 업로드   │     │             │
│             │     │ 5. mainImageUrl  │     │             │
│             │     │    자동 업데이트  │     │             │
│             │<────│ 6. URL 반환      │<────│             │
└─────────────┘     └─────────────────┘     └─────────────┘
```

**핵심 포인트:** `imageType=THUMBNAIL`로 업로드하면 `Performance.mainImageUrl`이 자동으로 업데이트됩니다.

---

## 8. 오류 처리

| HTTP Status | 설명 |
|-------------|------|
| 400 | 허용되지 않는 파일 형식 (JPEG, PNG, GIF, WebP만 허용) |
| 400 | 파일 크기 초과 (최대 10MB) |
| 401 | 인증 토큰 없음 또는 만료 |
| 403 | ADMIN 권한 없음 |
| 404 | 공연을 찾을 수 없음 |
| 500 | MinIO 서버 연결 오류 |

---

## 부록: 프로젝트 구조

```
src/main/kotlin/com/github/copyinaction/
├── storage/
│   ├── config/
│   │   └── MinioConfig.kt
│   ├── service/
│   │   └── StorageService.kt
│   └── dto/
│       └── ImageUploadDto.kt
└── performance/
    ├── controller/
    │   ├── PerformanceController.kt
    │   └── PerformanceImageController.kt
    ├── domain/
    │   └── Performance.kt          # visible 필드 포함
    ├── dto/
    │   └── PerformanceDto.kt       # visible 필드 포함
    └── service/
        └── PerformanceService.kt
```
